#include "fd_ed25519.h"
#include "fd_curve25519.h"

uchar * FD_FN_SENSITIVE
fd_ed25519_public_from_private( uchar         public_key [ static 32 ],
                                uchar const   private_key[ static 32 ],
                                fd_sha512_t * sha ) {

  //  RFC 8032 - Edwards-Curve Digital Signature Algorithm (EdDSA)
  //
  //  5.1.5.  Key Generation
  //
  //  The private key is 32 octets (256 bits, corresponding to b) of
  //  cryptographically secure random data.  See [RFC4086] for a discussion
  //  about randomness.
  //
  //  The 32-byte public key is generated by the following steps.
  //
  //  1.  Hash the 32-byte private key using SHA-512, storing the digest in
  //      a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
  //      used for generating the public key.

  uchar s[ FD_SHA512_HASH_SZ ];
  fd_sha512_fini( fd_sha512_append( fd_sha512_init( sha ), private_key, 32UL ), s );

  //  2.  Prune the buffer: The lowest three bits of the first octet are
  //      cleared, the highest bit of the last octet is cleared, and the
  //      second highest bit of the last octet is set.

  s[ 0] &= (uchar)0xF8;
  s[31] &= (uchar)0x7F;
  s[31] |= (uchar)0x40;

  //  3.  Interpret the buffer as the little-endian integer, forming a
  //      secret scalar s.  Perform a fixed-base scalar multiplication
  //      [s]B.

  fd_ed25519_point_t sB[1];
  fd_ed25519_scalar_mul_base_const_time( sB, s );

  //  4.  The public key A is the encoding of the point [s]B.  First,
  //      encode the y-coordinate (in the range 0 <= y < p) as a little-
  //      endian string of 32 octets.  The most significant bit of the
  //      final octet is always zero.  To form the encoding of the point
  //      [s]B, copy the least significant bit of the x coordinate to the
  //      most significant bit of the final octet.  The result is the
  //      public key.

  fd_ed25519_point_tobytes( public_key, sB );

  /* Sanitize */

  fd_memset_explicit( s, 0, FD_SHA512_HASH_SZ );
  fd_sha512_init( sha );

  return public_key;
}

uchar * FD_FN_SENSITIVE
fd_ed25519_sign( uchar         sig[ static 64 ],
                 uchar const   msg[], /* msg_sz */
                 ulong         msg_sz,
                 uchar const   public_key[ static 32 ],
                 uchar const   private_key[ static 32 ],
                 fd_sha512_t * sha ) {

  //  RFC 8032 - Edwards-Curve Digital Signature Algorithm (EdDSA)
  //
  //  5.1.6.  Sign
  //
  //  The inputs to the signing procedure is the private key, a 32-octet
  //  string, and a message M of arbitrary size.  For Ed25519ctx and
  //  Ed25519ph, there is additionally a context C of at most 255 octets
  //  and a flag F, 0 for Ed25519ctx and 1 for Ed25519ph.
  //
  //  1.  Hash the private key, 32 octets, using SHA-512.  Let h denote the
  //      resulting digest.  Construct the secret scalar s from the first
  //      half of the digest, and the corresponding public key A, as
  //      described in the previous section.  Let prefix denote the second
  //      half of the hash digest, h[32],...,h[63].

  uchar s[ FD_SHA512_HASH_SZ ];
  fd_sha512_fini( fd_sha512_append( fd_sha512_init( sha ), private_key, 32UL ), s );
  s[ 0] &= (uchar)0xF8;
  s[31] &= (uchar)0x7F;
  s[31] |= (uchar)0x40;
  uchar * h = s + 32;

  /* public_key is an input */

  //  2.  Compute SHA-512(dom2(F, C) || prefix || PH(M)), where M is the
  //      message to be signed.  Interpret the 64-octet digest as a little-
  //      endian integer r.

  uchar r[ FD_SHA512_HASH_SZ ];
  fd_sha512_fini( fd_sha512_append( fd_sha512_append( fd_sha512_init( sha ), h, 32UL ), msg, msg_sz ), r );

  //  3.  Compute the point [r]B.  For efficiency, do this by first
  //      reducing r modulo L, the group order of B.  Let the string R be
  //      the encoding of this point.

  fd_curve25519_scalar_reduce( r, r );           /* reduce r mod L */
  fd_ed25519_point_t R[1];
  fd_ed25519_scalar_mul_base_const_time( R, r ); /* R = [r]B */
  fd_ed25519_point_tobytes( sig, R );

  //  4.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
  //      64-octet digest as a little-endian integer k.

  /* note: all inputs to k are public values */
  uchar k[ FD_SHA512_HASH_SZ ];
  fd_sha512_fini( fd_sha512_append( fd_sha512_append( fd_sha512_append( fd_sha512_init( sha ),
                  sig, 32UL ), public_key, 32UL ), msg, msg_sz ), k );

  //  5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce k
  //      modulo L first.
  //
  //  6.  Form the signature of the concatenation of R (32 octets) and the
  //      little-endian encoding of S (32 octets; the three most
  //      significant bits of the final octet are always zero).

  fd_curve25519_scalar_reduce( k, k );
  fd_curve25519_scalar_muladd( ((uchar *)sig)+32, k, s, r );

  /* Sanitize */

  fd_memset_explicit( s, 0, FD_SHA512_HASH_SZ );
  fd_memset_explicit( r, 0, FD_SHA512_HASH_SZ );
  fd_sha512_init( sha );

  return sig;
}

int
fd_ed25519_verify( uchar const   msg[], /* msg_sz */
                   ulong         msg_sz,
                   uchar const   sig[ static 64 ],
                   uchar const   public_key[ static 32 ],
                   fd_sha512_t * sha ) {

  //  RFC 8032 - Edwards-Curve Digital Signature Algorithm (EdDSA)
  //
  //  5.1.7.  Verify
  //
  //  1.  To verify a signature on a message M using public key A, with F
  //      being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or
  //      Ed25519ph is being used, C being the context, first split the
  //      signature into two 32-octet halves.  Decode the first half as a
  //      point R, and the second half as an integer S, in the range
  //      0 <= s < L.  Decode the public key A as point A'.  If any of the
  //      decodings fail (including S being out of range), the signature is
  //      invalid.

  uchar const * r = sig;
  uchar const * S = sig + 32;

  /* Check scalar s */
  if( FD_UNLIKELY( !fd_curve25519_scalar_validate( S ) )) {
    return FD_ED25519_ERR_SIG;
  }

  /* Decompress public_key and point r, concurrently */
  fd_ed25519_point_t Aprime[1], R[1];
  int res = fd_ed25519_point_frombytes_2x( Aprime, public_key,   R, r );

  /* Check public key and point r:
     1. both public key and point r decompress successfully (RFC)
     2. both public key and point r are small order (verify_strict)

     There's another check that we currently do NOT enforce:
     whether public key and point r are canonical.
     Dalek 2.x (currently used by Agave) does NOT do any check.
     Dalek 4.x checks that the point r is canonical, but accepts
     a non canonical public key.

     Note: I couldn't find any test with non canonical points
     (all tests are non canonical + low order, that are excluded by
     the verify_strict rule). The reason is that to write such a
     test one needs to know the discrete log of a non canonical point.

     The following code checks that r is canonical (we can add it
     in when Agave switches to dalek 4.x).

        uchar compressed[ 32 ];
        fd_ed25519_affine_tobytes( compressed, R );
        if( FD_UNLIKELY( !fd_memeq( compressed, r, 32 ) ) ) {
          return FD_ED25519_ERR_SIG;
        }
    */
  if( FD_UNLIKELY( res ) ) {
    return res == 1 ? FD_ED25519_ERR_PUBKEY : FD_ED25519_ERR_SIG;
  }
  if( FD_UNLIKELY( fd_ed25519_affine_is_small_order(Aprime) ) ) {
    return FD_ED25519_ERR_PUBKEY;
  }
  if( FD_UNLIKELY( fd_ed25519_affine_is_small_order(R) ) ) {
    return FD_ED25519_ERR_SIG;
  }

  //  2.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
  //      64-octet digest as a little-endian integer k.

  uchar k[ 64 ];
  fd_sha512_fini( fd_sha512_append( fd_sha512_append( fd_sha512_append( fd_sha512_init( sha ),
                  r, 32UL ), public_key, 32UL ), msg, msg_sz ), k );
  fd_curve25519_scalar_reduce( k, k );

  //  3.  Check the group equation [8][S]B = [8]R + [8][k]A'.  It's
  //      sufficient, but not required, to instead check [S]B = R + [k]A'.

  /* Compute R = [k](-A') + [S]B, with B base point.
     Note: this is not the same as R = [-k]A' + [S]B, because the order
     of A' is 8l. Computing -k mod 8l would work. */
  fd_ed25519_point_t Rcmp[1];
#if 1
  fd_ed25519_point_neg( Aprime, Aprime );
#else
  /* this works too, and explains how batch verify (strict) works */
  fd_curve25519_scalar_neg_mod8l( k, k );
#endif
  fd_ed25519_double_scalar_mul_base( Rcmp, k, Aprime, S );

  /* Compare R (computed) and R from signature.
     Note: many implementations do this comparison by compressing Rcmd,
     and compare it against the r buf as it appears in the signature.
     This implicitly prevents non-canonical R.
     However this also hides a field inv to compress Rcmp.
     In our implementation we compare the points (see the comment
     above on "Check public key and point r" for details). */
  if( FD_LIKELY( fd_ed25519_point_eq_z1( Rcmp, R ) ) ) {
    return FD_ED25519_SUCCESS;
  }
  return FD_ED25519_ERR_MSG;
}

int fd_ed25519_verify_batch_single_msg( uchar const   msg[], /* msg_sz */
                                        ulong const   msg_sz,
                                        uchar const   signatures[ static 64 ], /* 64 * batch_sz */
                                        uchar const   pubkeys[ static 32 ],    /* 32 * batch_sz */
                                        fd_sha512_t * shas[ 1 ],               /* batch_sz */
                                        uchar const   batch_sz ) {
#define MAX 16
  if( FD_UNLIKELY( batch_sz == 0 || batch_sz > MAX ) ) {
    return FD_ED25519_ERR_SIG;
  }

  /* Using MSM introduces an overhead, so for batch_sz==1 it's better
     to just call fd_ed25519_verify. */
  if ( batch_sz==1 ) {
    return fd_ed25519_verify( msg, msg_sz, signatures, pubkeys, shas[0] );
  }

#if 0
  /* Naive */
  for( uchar i=0; i<batch_sz; i++ ) {
    int res = fd_ed25519_verify( msg, msg_sz, &signatures[ i*64 ], &pubkeys[ i*32 ], shas[0] );
    if( FD_UNLIKELY( res != FD_ED25519_SUCCESS ) ) {
      return res;
    }
  }
  return FD_ED25519_SUCCESS;
#else

  fd_ed25519_point_t points [2*MAX];      /* points for MSM */
  uchar              scalars[2*MAX * 32]; /* scalars for MSM */
  uchar              k      [MAX * 32];   /* k_j for each signature */

  /* The first batch_sz points are the R_j, the last are A'_j.
     Scalars will be stored accordingly. */
  fd_ed25519_point_t * R =      &points[0];
  fd_ed25519_point_t * Aprime = &points[batch_sz];

  /* First, we validate scalars, decompress public keys and points R_j,
     check low order points, and compute k_j.
     TODO: optimize, this is 20-25% of the total time. */
  for( int j=0; j<batch_sz; j++ ) {

    uchar const * r = signatures + 64*j;
    uchar const * S = signatures + 32 + 64*j;
    uchar const * public_key = pubkeys + 32*j;

    /* Check scalar s */
    if( FD_UNLIKELY( !fd_curve25519_scalar_validate( S ) )) {
      return FD_ED25519_ERR_SIG;
    }

    /* Decompress public_key and point r, concurrently */
    int res = fd_ed25519_point_frombytes_2x( &Aprime[j], public_key,   &R[j], r );

    /* Check public key and point r */
    if( FD_UNLIKELY( res ) ) {
      return res == 1 ? FD_ED25519_ERR_PUBKEY : FD_ED25519_ERR_SIG;
    }
    if( FD_UNLIKELY( fd_ed25519_affine_is_small_order(&Aprime[j]) ) ) {
      return FD_ED25519_ERR_PUBKEY;
    }
    if( FD_UNLIKELY( fd_ed25519_affine_is_small_order(&R[j]) ) ) {
      return FD_ED25519_ERR_SIG;
    }

    /* Compute scalars k_j */
    uchar _k[ 64 ];
    fd_sha512_fini( fd_sha512_append( fd_sha512_append( fd_sha512_append( fd_sha512_init( shas[j] ),
                    r, 32UL ), public_key, 32UL ), msg, msg_sz ), _k );
    fd_curve25519_scalar_reduce( &k[32*j], _k );
  }

  /* Batch verify with MSM.
     Note: if we detect an issue with MSM, we jump to fallback, where we do batch_sz
     fd_ed25519_double_scalar_mul_base(), i.e. we verify all signatures independently.

     To verify 1 signature we check the equation:
       R = [k](-A') + [S]B
     that we can rewrite as:
       R + [k](A') - [S]B = 0

     To verify n signatures we have to check the n equations:
       R_0 + [k_0] A'_0 - [S_0] B = 0
       R_1 + [k_1] A'_1 - [S_1] B = 0
       ...
       R_j + [k_j] A'_j - [S_j] B = 0
       ...

     We can batch verify the n equation using MSM. To do it securely,
     we have to multiply each equation by a random factor w_j, before
     adding all terms together. We set w_0 = 1.
           R_0 + [k_0] A'_0 - [S_0] B
       + ( R_1 + [k_1] A'_1 - [S_1] B ) * w_1
       +   ...
       + ( R_j + [k_j] A'_j - [S_j] B ) * w_j
           ... = 0

     Note that we can factor together all the coefficients of B
     (B is the base point and has order l prime), and leave R_0 out
     of the MSM and just add it at the end. So, the bulk of the
     computation is a MSM with 2*n points.

     The cofactors w_j are computed by hashing all inputs into a seed `rnd`,
     and repeatedly hashing rnd into w_j. For convenience we use sha512
     (and for comparison, Dalek uses the Merlin protocol based on sha3).

     There's a catch! We want to implement batch verify_strict
     (Dalek does NOT currently implement batch verify_strict).
     The critical part is that any of the R_j and A'_j may have a
     torsion component, so we need to carefully analyze the terms
     [w_j] R_j and [w_j*k_j] A'_j.

     The first remark is that [w_j*k_j] has to be done mod 8*l (viceversa,
     computing the coefficient of B can be done mod l).

     The second remark is that if w_j is random, there's a chance that
     both w_j % 8 == 0, and w_j*k_j % 8 == 0. In this case the torsion
     may cancel out and an invalid signature may appear as valid.

     Note that honestly generated signatures do NOT have torsion, so
     for the vast majority of the signatures that we have to verify,
     the computation will use MSM and will be accelerated.
     In the "unfortunate" case where 1) a signature j has torsion, and
     2) both w_j % 8 == 0, and w_j*k_j % 8 == 0, we fall back to verifying
     each signature independently. */

  /* Generate initial randomness. */
  uchar rnd[64]; uchar w[32];
  fd_sha512_fini( fd_sha512_append( fd_sha512_append( fd_sha512_init( shas[0] ),
                  "batch-verify", 12 ), &scalars[batch_sz/2], 32*(ulong)batch_sz/2 ), rnd );

  fd_memcpy( &scalars[0], signatures + 32 + 64*0, 32 ); // copy S_0 from signature 0
  fd_memcpy( &scalars[32*(0+batch_sz)], &k[32*0], 32 ); // copy k_0
  for( int j=1; j<batch_sz; j++ ) {
    uchar const * S = signatures + 32 + 64*j;

    /* Generate random w_j */
    fd_sha512_fini( fd_sha512_append( fd_sha512_init( shas[0] ), rnd, 64 ), rnd );
    fd_curve25519_scalar_reduce( w, rnd );

    /* Compute scalars:
       - scalars[batch_sz+j] = k_j * w_j mod 8*l, coefficient of A'_j
       - scalars[j] = w_j, coefficient of R_j (excluding R_0)
       - scalars[0] = \sum w_j S_j, coefficient of base point B */

    /* If w is random, there's a chance that it'll nullify the torsion in R_j or A'_j.
       If we detect it, first we try to fix it by incrementing w_j by 1.
       Failing that, we fall back to validating each signature independently. */
    fd_curve25519_scalar_mul_mod8l( &scalars[32*(j+batch_sz)], &k[32*j], w );
    if (scalars[32*(j+batch_sz)] % 8 == 0 || w[0] % 8 == 0) {
      w[0] = (uchar)(w[0] + 1); /* w_j++, still random */
      fd_curve25519_scalar_mul_mod8l( &scalars[32*(j+batch_sz)], &k[32*j], w );
    }
    if (scalars[32*(j+batch_sz)] % 8 == 0 || w[0] % 8 == 0) {
      goto fallback;
    }

    fd_memcpy( &scalars[32*j], w, 32 );
    fd_curve25519_scalar_muladd( &scalars[0], S, w, &scalars[0] );
  }

  /* Compute the MSM and add R0. */
  fd_ed25519_point_t res[1];
  fd_curve25519_scalar_neg( &scalars[0], &scalars[0] );
  fd_ed25519_multi_scalar_mul_base( res, scalars, points, 2*(ulong)batch_sz );

  fd_ed25519_point_add( res, res, &points[0] );

  if( FD_LIKELY( fd_ed25519_point_is_zero( res ) ) ) {
    return FD_ED25519_SUCCESS;
  }
  return FD_ED25519_ERR_MSG;
  /* Batch verify with MSM ends here. */

  /* Fallback: compute batch_sz fd_ed25519_double_scalar_mul_base(),
     i.e. verify each signature independently. */
fallback:
  for( uchar j=0; j<batch_sz; j++ ) {
    uchar const * S = signatures + 32 + 64*j;

    fd_ed25519_point_neg( &Aprime[j], &Aprime[j] );
    fd_ed25519_double_scalar_mul_base( res, &k[32*j], &Aprime[j], S );
    if( FD_UNLIKELY( !fd_ed25519_point_eq_z1( res, &R[j] ) ) ) {
      return FD_ED25519_ERR_MSG;
    }

  }
  return FD_ED25519_SUCCESS;
#endif
#undef MAX
}

char const *
fd_ed25519_strerror( int err ) {
  switch( err ) {
  case FD_ED25519_SUCCESS:    return "success";
  case FD_ED25519_ERR_SIG:    return "bad signature";
  case FD_ED25519_ERR_PUBKEY: return "bad public key";
  case FD_ED25519_ERR_MSG:    return "bad message";
  default: break;
  }
  return "unknown";
}
