const fs = require("fs");
const xml2js = require("xml2js");
const path = require('path');

function filterKeys(el, excludeKeys) {
  return Object.fromEntries(
    Object.entries(el.$).filter(([k]) => !excludeKeys.includes(k))
  );
}

function getChildValues(el) {
  let childList = [];
  for (const [key, value] of Object.entries(el)) {
    if (key !== "$") {
      childList.push(value);
    }
  }
  return childList;
}

function getChildKeys(el) {
  let childList = [];
  for (const [key, value] of Object.entries(el)) {
    if (key !== "$") {
      childList.push(key);
    }
  }
  return childList;
}

function printAttrAsList(el) {
  return (
    Object.entries(el)
      .map(([k, v]) => `- **${k}**: ${v}`)
      .join("\n") + "\n\n"
  );
}

function getHeadingAttrs(el) {
  const attrs = filterKeys(el, ["name"]);
  const attrPairs = Object.entries(attrs)
    .map(([k, v]) => `${k}: ${v}`)
    .join(", ");
  return attrPairs ? `${el.$.name} (${attrPairs})` : el.$.name;
}

function sanitizeAnchor(txt) {
  return txt
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function parseNode(el, hdr, type) {
  let md = `## ${hdr}\n`;
  md += `${el.$.name} is a ${type} Type\n`;

  let enumHdr = filterKeys(el, ["name"]);
  md += printAttrAsList(enumHdr);

  let childVals = getChildValues(el);
  let childKeys = getChildKeys(el);

  childVals.forEach((typeKey, idx) => {
    md += `### Type: ${childKeys[idx]}\n\n`;

    const typeKeyHdrs = Object.keys(typeKey[0]["$"]);
    md += typeKeyHdrs.join(" | ") + "\n";
    md += typeKeyHdrs.map(() => "---").join(" | ") + "\n";

    typeKey.forEach((typeVal) => {
      const row = typeKeyHdrs
        .map((header) => typeVal["$"][header] || "")
        .join(" | ");
      md += row + "\n";
    });
    md += "\n";
  });

  return md;
}

function genSummary(headings) {
  let sum = "## Summary\n\n";
  sum += "| Metric Name | Type | Description |\n";
  sum += "| --- | --- | --- |\n";

  headings.forEach((heading) => {
    const anchor = sanitizeAnchor(heading.name);
    const desc = heading.desc || "";
    sum += `| [${heading.name}](#${anchor}) | ${heading.type} | ${desc} |\n`;
  });

  sum += "\n";
  return sum;
}

// Pre-Traverse nodes to store descriptions
function extractDescriptions(metrics) {
  const desc = {};
  metrics.group?.forEach((el) => {
    el.counter?.forEach((counter) => {
      if (counter.$ && counter.$.enum) {
        desc[counter.$.enum] = counter.$.summary;
      }
    });
  });
  return desc;
}

function parseMetrics(xmlContent) {
  parser.parseString(xmlContent, (err, result) => {
    if (err) {
      throw err;
    }

    const metrics = result.metrics;

    let headings = [];
    let md = "";

    let desc = extractDescriptions(metrics);
    
    metrics.enum?.forEach((el) => {
      const hdr = getHeadingAttrs(el);
      headings.push({ name: hdr, desc: desc[el.$.name], type: "Enum" });
      md += parseNode(el, hdr, "Enum");
      md += "\n";
    });

    metrics.group?.forEach((el) => {
      const hdr = getHeadingAttrs(el);
      headings.push({ name: hdr, desc: desc[el.$.name], type: "Group" });
      md += parseNode(el, hdr, "Group");
      md += "\n";
    });
    
    introduction = `<!-- THIS FILE WAS GENERATED BY genMetrics.js. DO NOT EDIT BY HAND! -->

# Metrics

## Introduction

This page describes all possible metrics that could potentially be collected 
and reported by Firedancer. Metrics are grouped into categories and are essential 
for monitoring the system's performance, debugging issues, and ensuring operational 
stability.

To maintain consistency and ensure that monitoring tools relying on these metrics 
are not disrupted, all metrics are designed to be backwards compatible. Existing 
metric names will not be changed to avoid breaking dependencies. Instead, outdated 
metrics will be deprecated, and new metrics will be introduced to accommodate any 
required changes or enhancements.

## Metrics Structure

Metrics are categorized into \`enum\` and \`group\` types:

- **\`<enum>\`**: Defines a set of named values, usually representing different 
states or types. These are useful for categorizing discrete states or results.
- **\`<group>\`**: Organizes related metrics into groups. Each group can contain multiple 
metrics defined using \`<counter>\`, \`<gauge>\`, \`<histogram>\` and \`<summary>\` 
elements.

Each \`<enum>\` and \`<group>\` element has a \`name\` attribute that uniquely 
identifies it. The metrics within a \`<group>\` are defined with specific attributes 
and optionally detailed descriptions.

For more information on these metric types, please refer to the 
[Prometheus documentation](https://prometheus.io/docs/concepts/metric_types/#summary).
      \n\n`;
    introduction += genSummary(headings);
    md = introduction + md;

    const outFile = "../guide/metrics.md";
    fs.writeFileSync(outFile, md);
    console.log("Metrics documentation updated at:", path.resolve(outFile));
  });
}

const inFile = "../../src/disco/metrics/metrics.xml";
const xmlContent = fs.readFileSync(
  inFile,
  "utf-8"
);
const parser = new xml2js.Parser();

parseMetrics(xmlContent);
